set more off
set matsize 11000
cd "D:\milife"
/*
Questions:
How is certas IDs defined? Are the certas id upnique to the phone?
where is gmt and local time coming from? phone or server?
	gmt is the time recorded from the phone. GMT is converted to Local time at the time of syncing using the time difference between local CA time and GMT at the time of syncing. 
	GMT before time change will be converted to local correctly if synced before time change but off by an hour (+ or -) if synced after time change. 
	gmt is the unique time we should use to convert to local by ourselves. 

what is the number and time in the filename names? is the number certasid and time sync time?
how is survey vs. diary defined?
how are individual csv files generated? we see that one individual can have more than one files, can two person's questionnaires go into one filename? 
is it correct to say that each csv file contains no duplicate sessions? 
How can two of the respondents each have two certas IDs, while the contents are duplicates? 
how are session numbers generated? are they from the phone? can one session have more than one session number, due to sync or other issues? 
*/
/*
programs in the following bracket are for testing ideas or generating correction files only
****** dealing with
****** end 
the following mark identifies a section when a datafile is saved
****
the following mark is for sectional statements of purpose and conclusion
***
the following mark is for explaing the purpose of the following command
**
the following mark is for explaing findings from the previous command
*
*/

**** this part should be run for the folder with the ENTIRE collection of raw files generated by certas. 
cd "C:\milife\miLife_eDiarydata\RawPackets9.30.11\"
local rlst : dir . files "*.csv"
local count=0
*di `count'
*di `"`rlst'"'
foreach x in `rlst' {
	insheet using `x', names c clear
	tostring datecreatedgmt datecreatedlocal questionnaire question answer, replace
	*** skip if no case
	if _N>0 {
		gen filename="`x'"
		local count=`count'+1
		gen fileid=`count'
		capture tostring v*, replace
		save `x'.dta, replace
	}
	else save `x'.dta, replace
}
gen last=1
foreach x in `rlst' {
	append using `x'.dta
}
drop if last==1
drop last id
gen idall=_n
save C:\milife\raw_all.dta, replace


****
cd "D:\milife"
use raw_all.dta, clear
replace filename=subinstr(filename, "responsetext-", "", 1)
replace filename=subinstr(filename, ".csv", "", 1)
replace filename=subinstr(filename, "-", "_", 1)
split filename, p("_")
drop filename
rename filename1 certasid

*** mark filenames with question=="item#" as trial runs. indicator is trialsum>0 . 
*** when trialsum>0, there are no id questions. they are named item1 or item55
*** trialsum>0 correspond to three digit certasid
/*
split question, p(em)
gen trial=1 if question1=="It"
bysort fileid: egen trialsum=total(trial)
*/
*** all ids from the certasid=6666 or 9999 are false ids. 
*** all 3 and 4 digit certasids are not used in any subject according to the notes file. 
drop if length(certasid)>2
gen double tfile=clock(filename2, "MDYhms")

replace answer=answer+", "+v7+", "+v8+", "+v9+", "+v10+", "+v11+", "+v12
replace answer=subinstr(answer, ".,", ",", .)
replace answer=subinstr(answer, ", , , , , , ", "", .)
replace answer=subinstr(answer, ", , , , , ", "", .)
replace answer=subinstr(answer, ", , , , ", "", .)
replace answer=subinstr(answer, ", , , ", "", .)
replace answer=subinstr(answer, ", , ", "", .)
replace answer=trim(answer)
replace answer=subinstr(answer, ".", "", -1)
drop v*
gen double tlocal=clock(datecreatedlocal, "MDYhms")
replace datecreatedgmt=subinstr(datecreatedgmt, "T", " ", .)
gen double tgmt=clock(datecreatedgmt, "YMDhms")
gen td=(tlocal-tgmt)/(1000*60*60)
format tgmt tlocal tfile %tc

drop datecreatedgmt datecreatedlocal filename2
save raw_all1, replace

****
use raw_all1, clear
*bysort fileid session: gen na=_N
split question, p("ID")
gen id=answer if strpos(question,"ID")
destring id, replace
drop question1 question2
replace id=4313 if id==1234 & certasid=="20"
replace id=8908 if id==1234 & certasid=="07"
gen filefalse=1 if id==6666 /*the session with id=1405 is id only. the sessions with id=6666 are clearly trials*/
bysort fileid: egen filefalsei=total(filefalse)
drop if filefalsei>0
drop filefalse*
bysort fileid: egen idmin=min(id)
bysort fileid: egen idmax=max(id)
*** drop if no id in file
drop if idmin==.
save raw_all1a, replace

****** dealing with the 4313 and 8908 as 1234 problem
	* 100	4313	4/16/2011	949-812-2518	20	entering daily survey participant number as 1234
	* 74	8908	1/25/2011	949-233-8489	7	entering daily survey participant number as 1234
	*	8908 inputted 1234 as 1231 once. will correct later automatically. 
	/*
	use raw_all1a, clear
	drop if id==.
	gen idbad=1 if id==1234 | id==4313
	bysort fileid: egen idbadi=total(idbad)
	bysort fileid: gen idcount=_N
	keep if idbadi>0
	ta id certasid
	*/
	*dealing with id=6666 on right phones certasid=08
	/* 
	use raw_all1a, clear
	drop if id==.
	replace id=4313 if id==1234 & certasid=="20"
	replace id=8908 if id==1234 & certasid=="07"
	sort id
	merge m:1 id using id

	gen filefalse=1 if id==6666 
	*the session with id=1405 is id only. the sessions with id=6666 are clearly trials
	bysort fileid: egen filefalsei=total(filefalse)
	keep filefalsei>0
	list if filefalsei>0
	*/
****** end

****** dealing with wrong ids due to typo
	use raw_all1a, clear
	drop if id==.
	keep if (idmax-idmin)>0
	*** session is in same order as gmt in each file
	sort fileid session
	by fileid: gen nf=_n
	by fileid: gen nfa=_N
	sort fileid tgmt
	by fileid: gen nt=_n

	sort id
	merge m:1 id using id, keep(1 3)
	sort fileid session session
	bysort fileid id: gen n=_n
	bysort fileid id: gen n2=_N
	*** this shows in each fileid there are only up to 2 unique ids, no more!
	/*  
	keep if n==1
	bysort fileid: gen countid=_N
	ta countid
	*/
	bysort fileid: egen idmean=mean(id)
	gen idfalse=1 if (id==idmax & abs(idmean-idmax)>abs(idmean-idmin)) | (id==idmin & abs(idmean-idmax)<abs(idmean-idmin))
	gen m=1 if nf==nfa | nf==1
	bysort m: ta _merge idfalse if n==1, missing
	sort fileid
	list *id* _merge n2 m if n==1
	replace idfalse=1 if id==4104 & idmin==1404 & idmax==4104 
	replace id=1404 if id==4104 & idmin==1404 & idmax==4104 
	* 4104 invalid id and typo
	*** coorect the false ids. 4313 (a correct id) was changed to 1234 (a trial id). 
	replace id=idmin if id==idmax & abs(idmean-idmax)>abs(idmean-idmin) & idfalse==1
	replace id=idmax if id==idmin & abs(idmean-idmax)<abs(idmean-idmin) & idfalse==1
	keep if idfalse==1
	keep idall id
	sort idall
	save idfalse, replace
****** end

****
use raw_all1a, clear
sort idall
merge 1:1 idall using idfalse, nogen update replace
sort id 
*** test that all ids now match the id list, and yes they do. 
merge m:1 id using id
ta id _, missing
drop _ idmin idmax
drop if questionnaire=="AuditTrail"
rename id idq
bysort fileid: egen id=mean(idq)
save raw_all1b, replace

****** deal with id 1001(3,7) and 1201(16,20) use different certasids, shown in (). 
	*** for 1201, 20 is a partial repeat of 16 for two days. 
	*** the only file with certasid=20 is one of many dup files for sessions 3, 15, 28
	*** certasid=20 & id=1201 should be dropped
	/*
	use raw_all1b, clear
	keep if inlist(id,1201)
	bysort id certasid: egen double idgmtstart=min(tgmt)
	bysort id certasid: egen double idgmtend=max(tgmt)
	bysort id certasid: egen double idlocalstart=min(tlocal)
	bysort id certasid: egen double idlocalend=max(tlocal)
	format idgmt* idlocal* %tc
	order id certasid fileid session tgmt idgmtstart idgmtend idlocalstart idlocalend tlocal
	sort id tfile tlocal
	bysort fileid: gen nfile=_N
	bysort fileid session: gen nqperssn=_N
	drop if idq==.
	ta fileid certas, sum(nfile)
	bysort certasid fileid: ta session 
	* looks like only the single certasid=20 file is complete, all others are partial ones early sessions. 
	duplicates tag id session tgmt tlocal questionnaire question answer nqperssn, generate(dup1201)
	ta dup certasid 
	* each duplicates of individual sessions for id=1001 have equal # of items per session
	* see if other id showed up in fileid=1848, no
	*/

	*** for 1001, first part of 07 is repeat of 03 but with one hour delay. but later 07 took over. 
	*** certasid=07 should be used for id=1001
	/*
	use raw_all1b, clear
	keep if inlist(id,1001)
	bysort id certasid: egen double idgmtstart=min(tgmt)
	bysort id certasid: egen double idgmtend=max(tgmt)
	bysort id certasid: egen double idlocalstart=min(tlocal)
	bysort id certasid: egen double idlocalend=max(tlocal)
	format idgmt* idlocal* %tc
	order id certasid fileid session tgmt idgmtstart idgmtend idlocalstart idlocalend tlocal
	sort id tfile tlocal
	bysort fileid: gen nfile=_N
	bysort fileid session: gen nqperssn=_N
	drop if idq==.
	ta fileid certas, sum(nfile)
	bysort certasid fileid: ta session 
	* looks like only the single certasid=07 file is complete, all others are partial ones early sessions. 
	duplicates tag id session tgmt tlocal questionnaire question answer, generate(dup1001)
	sort tgmt certasid
	ta dup certasid
	ta fileid if cer=="03" & dup==0 
	* fileid=256 is the longer file for certasid=03
	ta session certasid
	sort session tgmt tfile 
	* sessions 41, 42, 43 are only in fileid=256 (the longest file for certasid=03 and id=1001)
	* evidence shows that the 4% discripency between standard vs DST is due to data input before time change and syncing after time change. 
	* see if other id showed up in fileid=644, no
	duplicates tag id session tgmt questionnaire question answer nqperssn, generate(dup1001a)
	ta dup1001a certasid 
	* each duplicates of individual sessions for id=1001 have equal # of items per session
	* so certasid=07 should be used for id=1001
	*/
****** end

****
use raw_all1b, clear
** correcting false certasid for id=1001 | 1201
drop if (id==1001 & certasid=="03") | (id==1201 & certasid=="20") 
sort id fileid session
save raw_all1c, replace

****** conclusion: each file contains no duplicate session ids
/*
use raw_all1c, clear
bysort fileid: gen nfile=_N
bysort fileid session: gen nqperssn=_N
drop if idq==.
*** each file contains no duplicate session ids
bysort fileid session: gen na=_N
bysort id session: gen n1a=_N
bysort fileid: gen n2a=_N
tab1 n*
*** some valid session id numbers are reused up to 7 times for an id. 
bysort id session tgmt: keep if _n==1
bysort id session: gen n1b=_N
ta session n1b
order id session n1b fileid tgmt
sort n1b id session tgmt
*/
****** end 

****** mark sessions to be dropped
use raw_all1c, clear
bysort fileid: gen nfile=_N
bysort fileid session: gen nqperssn=_N
drop if idq==.
duplicates tag id fileid session tgmt questionnaire question answer nqperssn, generate(dup)
*ta dup
duplicates tag id session tgmt questionnaire question answer nqperssn, generate(dup1)
*ta dup1
duplicates tag id session tgmt questionnaire question answer, generate(dup2)
*ta dup2
*ta dup1 dup2
* dup1=1/3 are different from dup2. so some id_session are different in length
*drop if dup1==dup2
*order id session fileid tgmt tlocal nqperssn tfile
*sort id session tfile
*** keep the longest session for otherwise duplicate sessions. duplicate sessions with same nqperssn are dealt with later. 
bysort id session tgmt: egen nqperssnmax=max(nqperssn)
/*
bysort id session tgmt: egen nqperssnmin=min(nqperssn)
gen nqperssnd=nqperssnmax-nqperssnmin
ta nqperssnd
keep if nqperssnd>0
order id session fileid tgmt nqperssn nqperssnmax nqperssnmin nqperssnd
keep id session fileid nqperssn nqperssnmax nqperssnmin nqperssnd
sort fileid session 
merge 1:m fileid session using raw_all1c, nogen keep(3)
sort id session tgmt
*/
keep if nqperssn==nqperssnmax
drop dup*
duplicates tag id session tgmt questionnaire question answer nqperssn, generate(dup1)
*ta dup1
duplicates tag id session tgmt questionnaire question answer, generate(dup2)
*ta dup2
*ta dup1 dup2
sort id tgmt
order id session tgmt
sort id session tgmt questionnaire question answer tfile
by id session tgmt questionnaire question answer: gen idsession=_n
* keeping the earliest synced data to reduce tlocal error due to time change. it makes some difference. 
keep if idsession==1
sort id tgmt
by id: gen idn=_n
replace idn=id*1000+idn
keep id fileid session idn
sort id fileid session idn
save idsession, replace
****** end

****
use raw_all1c, clear
sort id fileid session
merge m:1 id fileid session using idsession, nogen keep(3)
*** this shows all mismatch of DST and actual are due to delayed sync.
/*
gen dls=1 if inrange(tgmt,mdyhms(3,14,2010,10,0,0),mdyhms(11,7,2010,10,0,0)) | inrange(tgmt,mdyhms(3,13,2011,10,0,0),mdyhms(11,6,2011,10,0,0)) 
ta dls td, missing col
drop if (dls==1 & td==-7) | (dls==. & td==-8)
*/
replace question="PMNX07" if question=="PMN07"
replace question="PMNX08" if question=="PMN08"
replace question="PMNX09" if question=="PMN09"
sort id fileid session question tlocal
by id fileid session question: gen nq=_n
reshape wide idall answer tlocal tgmt, i(id fileid session question) j(nq)
ta answer1 answer2 if question=="PMTU12", missing
ta answer1 answer2 if question=="PMTU13", missing
replace answer1=answer2 if question=="PMTU12" & answer2~=""
replace answer1=answer2 if question=="PMTU13" & answer2~="" & answer1=="BACK BUTTON"
drop answer2 idall2 tlocal2 tgmt2
rename (answer1 idall1 tlocal1 tgmt1) (answer idall tlocal tgmt)
bysort id fileid session: gen nqperssn=_N
gen double tlocaln=tgmt-8*60*60*1000
replace tlocaln=tgmt-7*60*60*1000 if inrange(tgmt,mdyhms(3,14,2010,10,0,0),mdyhms(11,7,2010,9,0,0)) | inrange(tgmt,mdyhms(3,13,2011,10,0,0),mdyhms(11,6,2011,9,0,0))
format tlocaln %tc
*** eyeballing the wrong time stamps that are pointed out in the notes from the incorrect phone time when they were returned. make judgements and adjustments when needed. 
*** make changes in time stamps identified by notes and verified by Victor. 
gen prerestart=1 if tlocaln<mdyhms(2,14,2011,23,59,59) & id==6504
* may as well keep given that there are some data points. not all are DK. and there are some DK after restart anyway. 
replace tgmt=tgmt+3*60*60*1000 if inrange(tlocaln,mdyhms(8,13,2011,0,0,1),mdyhms(8,16,2011,23,59,59)) & id==4204
replace tlocal=tlocal+3*60*60*1000 if inrange(tlocaln,mdyhms(8,13,2011,0,0,1),mdyhms(8,16,2011,23,59,59)) & id==4204
replace tlocaln=tlocaln+3*60*60*1000 if inrange(tlocaln,mdyhms(8,13,2011,0,0,1),mdyhms(8,16,2011,23,59,59)) & id==4204
replace tgmt=tgmt+19*60*60*1000 if inrange(tlocaln,mdyhms(6,24,2011,21,0,1),mdyhms(6,30,2011,23,59,59)) & id==8913
replace tlocal=tlocal+19*60*60*1000 if inrange(tlocaln,mdyhms(6,24,2011,21,0,1),mdyhms(6,30,2011,23,59,59)) & id==8913
replace tlocaln=tlocaln+19*60*60*1000 if inrange(tlocaln,mdyhms(6,24,2011,21,0,1),mdyhms(6,30,2011,23,59,59)) & id==8913
order id fileid session idn nqperssn questionnaire question answer tgmt tlocaln certasid tfile
save milife_long_all, replace

***
/*
after true duplication sessions have been dropped, 
pocedures of identifying the incorrect time stamp for surveys and choosing the surveys in the final data. 
1, create markers for surveys started in the specified window
2, compare the start time to the average start for each person (by trimark) (scaled to the std of starting time for all persons and corresponding trimark) ///
	and numer of questions off the max number of questions answered for each person day and trimark (scaled to the std*2 nqperssn for all persons and corresponding trimark) ///
	and chose the session with smaller deviation
3, flag the first of repeated sessions that have the same max nqperssn but different starting time (by id day trimark) as the one used in the final data
*/
use milife_long_all, clear
drop if idq==.
gen dlocaln=int(hours(tlocaln)/24)
*order id fileid session idn dlocaln tgmt tlocaln tlocal questionnaire tgmtid qne nqperssn question answer certasid tfile
drop if nqperssn==1
gen trimark=question
replace trimark=subinstr(trimark, "ID01", "", 1)
gen hmslocaln=hh(tlocaln)+mm(tlocaln)/60+ss(tlocaln)/3600
gen hmstclocaln=hh(tlocaln)*60*60*1000+mm(tlocaln)*60*1000+(ss(tlocaln)+1)*1000
bysort trimark: sum hmslocaln, detail
*** decisions need to be made based on the following info as some of the entry time for the surveys are simply invalid
*histogram hmslocaln, bin(24) frequency xsize(6) ysize(8) by(trimark, rows(1))
*** make changes to obvious delayed entries that have passed midnight. move some surveys to the previous day
gen double tlocaln2=tlocaln
replace tlocaln2=tlocaln-hmstclocaln if hmslocaln<2 & trimark=="PM"
format tlocaln2 %tc
*** flag surveys when they are completed inside a specific window, note to use either tlocaln or the corrected tlocaln2
gen dlocaln2=int(hours(tlocaln2)/24)
gen hmslocaln2=hh(tlocaln2)+mm(tlocaln2)/60+ss(tlocaln2)/3600
ta trimark
ta trimark, sum(hmslocaln2)
gen aminwin=1 if inrange(hmslocaln2,4.5,14) & trimark=="AM" 
gen asinwin=1 if inrange(hmslocaln2,12,20) & trimark=="AS" 
gen pminwin=1 if inrange(hmslocaln2,16,23.99999) & trimark=="PM" 
gen hmslocalnpm2=hmslocaln+24 if hmslocaln<2 & trimark=="PM"
replace hmslocalnpm2=hmslocaln2 if trimark=="PM" & hmslocalnpm2==.
bysort id: egen idamavghms=mean(hmslocaln2) if aminwin==1
bysort id: egen idasavghms=mean(hmslocaln2) if asinwin==1
bysort id: egen idpmavghms=mean(hmslocalnpm2) if pminwin==1
egen idamsdhms=sd(hmslocaln2) if aminwin==1
egen idassdhms=sd(hmslocaln2) if asinwin==1
egen idpmsdhms=sd(hmslocalnpm2) if pminwin==1

gen amtoff=abs(hmslocaln2-idamavghms) if aminwin==1
gen astoff=abs(hmslocaln2-idasavghms) if asinwin==1
gen pmtoff=abs(hmslocalnpm2-idpmavghms) if pminwin==1

gen zamtoff=amtoff/idamsdhms if aminwin==1
gen zastoff=astoff/idassdhms if asinwin==1
gen zpmtoff=pmtoff/idpmsdhms if pminwin==1

gen ztoff=zamtoff if trimark=="AM"
replace ztoff=zastoff if trimark=="AS"
replace ztoff=zpmtoff if trimark=="PM"

bysort trimark: egen trisdnqperssn=sd(nqperssn) if ztoff~=. 
bysort id dlocaln2 trimark: egen maxnqperssn=max(nqperssn)
gen dmaxnqperssn=maxnqperssn-nqperssn
*** favor more complete surveys twice as much as close proximity to the average start time. 
gen zdmaxnqperssn=dmaxnqperssn/(trisdnqperssn*2)
egen minnsandtoff=rowmin(ztoff zdmaxnqperssn) if ztoff~=.
bysort id dlocaln2 trimark: egen mindnsandtoff=min(minnsandtoff)
gen final1=1 if mindnsandtoff==minnsandtoff & mindnsandtoff~=.
sort id dlocaln2 trimark final1 ztoff
by id dlocaln2 trimark final1: gen n1=_n
replace n1=. if final1==.

*order id dlocaln2 tlocaln2 trimark nqperssn ztoff maxnqperssn trisdnqperssn dmaxnqperssn zdmaxnqperssn minnsandtoff mindnsandtoff
* this shows that all the ones with n1>1 have the same nqperssn=maxnqperssn so anyone would be fine
bysort id dlocaln2 trimark final1: gen final=1 if n1==1 & final1==1
sort n1 id dlocaln2 trimark tlocaln2
ta final
keep id idn dlocaln2 tlocaln2 hmslocaln2 trimark aminwin asinwin pminwin ztoff zdmaxnqperssn final 
*** the following generate time difference in minutes between two consecutive sessions if final==1
sort idn
tempfile tmp
save `tmp'
keep if final==1
keep id idn tlocaln
sort idn
gen n=_n
gen tdsession=.
forvalues n= 2/`c(N)' {
	local n1=`n'-1
	quietly: replace tdsession= `= tlocaln[`n']' - `= tlocaln[`n1']' if n==`n1'
}
replace tdsession=tdsession/60000
sort id idn
by id: replace tdsession=. if _n==_N
keep idn tdsession
sort idn
merge 1:1 idn using `tmp', nogen
save milife_long_fssnlst, replace

use milife_long_all, clear
sort idn
merge m:1 idn using milife_long_fssnlst, nogen keep(3)
sort idn tlocaln
by idn: gen tperssn=(tlocaln[_N]-tlocaln[1]+1)/(60*1000)
/*
gen tdquestion=.
forvalues n= 2/`c(N)' {
	local n1=`n'-1
	quietly: replace tdquestion= `= tlocaln[`n']' - `= tlocaln[`n1']' if n==`n'
}
replace tdquestion=tdquestion/60000
by idn: replace tdquestion=. if _n==1
by idn: egen maxtdq=max(tdquestion)
*/

gen dow=dow(dlocaln2)
gen weekday=cond(dow>0 & dow<6,1,cond(dow==0 | dow==6,0,.))
gen weekend=cond(dow>0 & dow<6,0,cond(dow==0 | dow==6,1,.))
replace answer=subinstr(answer, "DontKnow", "", 1)
*replace answer=subinstr(answer, "DontKnow", "", 1) if question=="AMSQ01"
*replace answer=subinstr(answer, "DontKnow", "", 1) if question=="AMSQ02"
lab var id "participant id"
lab var fileid "certas raw file id"
lab var session "certas session id, not unique within id"
lab var idn "id*1000 + n, n is unique session identifier per id in chronological order"
lab var nqperssn "number of questions answered for each idn session"
lab var tgmt "GMT from phone"
lab var tlocaln "local time, calculated based on GMT, actual time"
lab var tlocaln2 "local time, calculated based on GMT, 0/2 pm survey corrected to the previous day"
lab var hmslocaln2 "hour of the day the session started, precision down to the second"
lab var dlocaln2 "local date, calculated based on GMT, 0/2 pm survey corrected to the previous day"
lab var dow "dayofweek based on dlocaln2, 0 is sunday, 0/2 pm survey corrected to the previous day"
lab var weekday "1=weekday, 0=weekend"
lab var weekend "1=weekend, 0=weekday"
lab var tfile "time of raw file, sync time"
lab var trimark "mark for AM AS PM"
lab var ztoff "starttime of session off the average of the person corresponding to each trimark, standardized"
lab var zdmaxnqperssn "number of questions off the max number of question by id dlocaln2 trimark, standardized"
lab var aminwin "am session in time window"
lab var asinwin "as session in time window"
lab var pminwin "pm session in time window"
lab var final "flag for final clean data, one of each trimark per day"
lab var tdsession "minutes between the first q of current final session and first q of the next final session"
lab var tperssn "minutes spent on the session"
keep id fileid session idn nqperssn questionnaire question answer tgmt tlocaln certasid tfile /*idall tlocal td idq*/ prerestart ///
	tdsession trimark tlocaln2 dlocaln2 hmslocaln2 aminwin asinwin pminwin ztoff zdmaxnqperssn final tperssn dow weekday weekend

save milife_long, replace


****
use milife_long, clear
keep id idn nqperssn questionnaire question answer ///
	dlocaln2 tlocaln2 hmslocaln2 trimark ztoff zdmaxnqperssn tdsession dow prerestart final tperssn weekday weekend

replace question=substr(question, 3, .)
*sort id dlocaln2
*by id: gen ndayinsvy=dlocaln2[_N]-dlocaln2[1]
reshape wide answer, i(idn) j(question, string)
order id idn nqperssn questionnaire ///
	dlocaln2 tlocaln2 hmslocaln2 trimark ztoff zdmaxnqperssn tdsession dow prerestart final tperssn weekday weekend
destring answer*, ignore("DontKnow") replace
gen answerSQ01a=hours(clock(answerSQ01,"hm"))
gen answerSQ02a=hours(clock(answerSQ02,"hm"))
histogram answerSQ01a, bin(24) frequency
histogram answerSQ02a, bin(24) frequency
twoway (scatter answerSQ02a answerSQ01a)
gen answerSQ01b=answerSQ01a
gen answerSQ02b=answerSQ02a
replace answerSQ02b=answerSQ02a-12 if answerSQ01a>15 & answerSQ02a>15 
replace answerSQ02b=answerSQ02a+12 if answerSQ01a>15 & answerSQ02a==0 
replace answerSQ01b=answerSQ01a+12 if (answerSQ01a>6 & answerSQ01a<12) & (answerSQ02a>0 & answerSQ02a<15)
replace answerSQ01b=answerSQ01a-12 if (answerSQ01a>=12 & answerSQ01a<17) & (answerSQ02a>0 & answerSQ02a<15)
replace answerSQ01b=answerSQ01a-12 if (answerSQ01a>10 & answerSQ01a<=12) & answerSQ02a==0 
replace answerSQ01b=answerSQ01a+12 if (answerSQ01a>6 & answerSQ01a<10) & answerSQ02a==0 
replace answerSQ02b=answerSQ02a+12 if (answerSQ01a>6 & answerSQ01a<=12) & answerSQ02a==0
replace answerSQ02b=answerSQ02a-12 if answerSQ01a<6 & answerSQ02a>15 
replace answerSQ02b=answerSQ02a+12 if (answerSQ01a>=0 & answerSQ01a<5) & answerSQ02a==0 
replace answerSQ02b=answerSQ02a+12 if (answerSQ01a>0 & answerSQ01a<5) & (answerSQ02a>0 & answerSQ02a<4) 
twoway (scatter answerSQ02b answerSQ01b)
gen dtsqb=answerSQ02b-answerSQ01b if answerSQ02b>answerSQ01b
replace dtsqb=24-answerSQ01b+answerSQ02b if answerSQ02b<answerSQ01b
label var dtsqb "hours slept for each am session"
histogram dtsqb, bin(24) frequency
gen dtsqba=dtsqb
replace dtsqba=. if final==.
bysort id dlocaln2: egen dtsqbb=mean(dtsqba)
drop dtsqba
label var dtsqbb "hours slept from am sessions, madd available for all sessions"
replace trimark=lower(trimark)
rename *, l

gen trimarki=1 if final==1 //cond(trimark=="am",1,cond(trimark=="as",2,3))
save milife_sessionwide_a, replace

use milife_sessionwide_a, clear
rename answer* *
save milife_sessionwide, replace

****
use question using milife_long, clear
replace q=lower(q)
bysort q: keep if _n==1
local qlst 
forvalues n= 1/`c(N)' {
	local qlst `qlst' `= question[`n']'
}

use milife_sessionwide_a, clear
keep if final==1
drop idn dtsqb
reshape wide nqperssn questionnaire tlocaln2 hmslocaln2 ztoff zdmaxnqperssn tdsession tperssn trimarki answer*, i(id dlocaln2) j(trimark, string)

unab vlst: *
unab qalst: answer*
local nqlst: list vlst - qalst
di "`nqlst'"
rename answer*am am*
rename answer*as as*
rename answer*pm pm*
keep `nqlst' `qlst'
order id dlocaln2 dow final dtsqbb
destring am* as* pm*, replace
save milife_daywide_t, replace

use milife_daywide_t, clear
lab var nqperssnam "number of quesitons answered for am session"
lab var questionnaiream "type of questionaire for am"
lab var tlocaln2am "starting local time (corrected) for am"
lab var hmslocaln2am "time of day in hours version of tlocaln2am"
lab var ztoffam "starttime of am session off the average of the person corresponding to each trimark, standardized"
lab var zdmaxnqperssnam "number of questions off the max number of am question by id dlocaln2, standardized"
lab var tdsessionam "minutes between the first q of current final session and first q of the next final session"
lab var trimarkiam "indicator for completion of an am session for the day"

sort id dlocaln2
gen trimarkiall=1 if trimarkiam==trimarkias==trimarkipm==1
*** response rate 
by id: gen ndayinsvy=dlocaln2[_N]-dlocaln2[1]+1
sort id dlocaln2
gen n=_n
gen tdday=.
forvalues n= 2/`c(N)' {
	local n1=`n'-1
	quietly: replace tdday= `= dlocaln2[`n']' - `= dlocaln2[`n1']' if n==`n1'
}
by id: replace tdday=. if _n==_N
by id: egen maxtdday=max(tdday)

bysort id: gen ndaywdiary=_N
bysort id: egen ndayall3d=total(trimarkiall)
bysort id: egen ndayam=total(trimarkiam)
bysort id: egen ndayas=total(trimarkias)
bysort id: egen ndaypm=total(trimarkipm)
bysort id: egen avgnqperssnam=mean(nqperssnam)
bysort id: egen avgnqperssnas=mean(nqperssnas)
bysort id: egen avgnqperssnpm=mean(nqperssnpm)
lab var ndayinsvy "number of days in survey"
lab var ndaywdiary "number of days completed any diary"
lab var ndayall3d "number of days completed all 3 diaries"
lab var maxtdday "largest number of days w/o any diary"
/*
bysort id: gen n1=_n
tab1 ndayinsvy ndaywdiary ndayall3d ndayam ndayas ndaypm avgnqperssnam avgnqperssnas avgnqperssnpm maxtdday if n1==1
*/

do daywide_labels.do
sort id
compress
save milife_daywide, replace

* programs to list the response rate of weekends

* programs to list the response rate of weekdays

